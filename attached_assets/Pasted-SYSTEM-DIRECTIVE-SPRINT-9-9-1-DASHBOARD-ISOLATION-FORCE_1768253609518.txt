SYSTEM DIRECTIVE: SPRINT 9.9.1 - DASHBOARD ISOLATION (FORCE OVERWRITE)

Context: The current codebase has a Critical P0 Vulnerability. The Dashboard methods (getDashboardStats, getRecentTasks) are Global (unscoped). They must be Tenant-Scoped immediately.

Task 1: Overwrite Storage Logic (server/storage.ts)

Action: Replace the getRecentTasks and getDashboardStats methods in DatabaseStorage with these secure versions.

Requirement: EVERY query must use .where(eq(..., merchantId)) or and(..., eq(..., merchantId)).

TypeScript

  // 1. SECURE: Recent Tasks (Scoped to Merchant)
  async getRecentTasks(merchantId: string, limit: number = 10): Promise<ScheduledTask[]> {
    return db.select().from(scheduledTasks)
      .where(eq(scheduledTasks.merchantId, merchantId)) // <--- CRITICAL SECURITY FIX
      .orderBy(desc(scheduledTasks.createdAt))
      .limit(limit);
  }
// 2. SECURE: Dashboard Stats (Scoped to Merchant) async getDashboardStats(merchantId: string) { // Scoped Pending Count const [pendingCount] = await db.select({ count: sqlcount(*)::int }) .from(scheduledTasks) .where(and( eq(scheduledTasks.status, TaskStatus.PENDING), eq(scheduledTasks.merchantId, merchantId) // <--- SCOPED ));

// Scoped Running Count
const [runningCount] = await db.select({ count: sql<number>`count(*)::int` })
  .from(scheduledTasks)
  .where(and(
    eq(scheduledTasks.status, TaskStatus.RUNNING),
    eq(scheduledTasks.merchantId, merchantId) // <--- SCOPED
  ));
// Scoped Revenue
const [totalRecovered] = await db.select({ 
  total: sql<number>`COALESCE(sum(recovered_cents), 0)::int` 
}).from(dailyMetrics)
  .where(eq(dailyMetrics.merchantId, merchantId)); // <--- SCOPED
// Scoped Success Rate (Last 7 Days)
const [successStats] = await db.select({
  success: sql<number>`count(*) filter (where metric_type = 'recovery_success')::int`,
  failed: sql<number>`count(*) filter (where metric_type = 'recovery_failed')::int`,
}).from(usageLogs)
  .where(and(
    eq(usageLogs.merchantId, merchantId), // <--- SCOPED
    sql`created_at > NOW() - INTERVAL '7 days'`
  ));
const totalAttempts = (successStats?.success || 0) + (successStats?.failed || 0);
const successRate = totalAttempts > 0 
  ? Math.round((successStats.success / totalAttempts) * 100) 
  : 100;
// Scoped Processing Rate
const [rateStats] = await db.select({
  count: sql<number>`count(*)::int`,
}).from(usageLogs)
  .where(and(
    eq(usageLogs.merchantId, merchantId), // <--- SCOPED
    sql`created_at > NOW() - INTERVAL '1 hour'`
  ));
const processingRate = Math.round((rateStats?.count || 0) / 60);
// Scoped Last Activity
const [lastLog] = await db.select()
  .from(usageLogs)
  .where(eq(usageLogs.merchantId, merchantId)) // <--- SCOPED
  .orderBy(desc(usageLogs.createdAt))
  .limit(1);
return {
  totalRecovered: totalRecovered?.total || 0,
  activeMerchants: 1, // Correct: User only sees themselves
  pendingTasks: pendingCount?.count || 0,
  runningTasks: runningCount?.count || 0,
  successRate,
  processingRate,
  lastProcessedAt: lastLog?.createdAt?.toISOString() || null,
  trends: { recovered: 0, merchants: 0, tasks: 0 },
};
}


**Task 2: Update the Interface (`server/storage.ts`)**
Action: Update IStorage to match the new signatures.

getRecentTasks(merchantId: string, limit?: number): Promise<ScheduledTask[]>;

getDashboardStats(merchantId: string): Promise<any>;

Task 3: Update the Route (server/routes.ts)

Action: Pass the req.merchant.id to the storage calls in /api/dashboard.

TypeScript

  app.get("/api/dashboard", requireAuth(), requireMerchant, async (req, res) => {
    try {
      const merchant = req.merchant!;
      // SECURE: Pass the ID
      const stats = await storage.getDashboardStats(merchant.id);
      const recentTasks = await storage.getRecentTasks(merchant.id, 5);
      // ... rest of handler