ðŸš¨ SYSTEM DIRECTIVE: SPRINT 11 - TICKET 11.2 (FINANCIAL INTEGRITY)
CONTEXT: We have a critical "Privilege Escalation" vulnerability in our billing logic. Currently, handleSubscriptionUpdated trusts the event.account field. If a malicious merchant creates a product named "Pro Plan" in their own Stripe Connected Dashboard and subscribes to it, the webhook will fire. Our system sees the Price ID matches "Pro" and upgrades them for free. We must effectively block all tenant-generated billing events.

OBJECTIVE: Enforce a "Trust Boundary" in the webhook handler. We only accept billing events from the Platform Account, not Connected Accounts.

ACTION PLAN
Target File: server/webhookHandlers.ts

Step 1: Locate handleSubscriptionUpdated It is likely at the bottom of the file.

Step 2: Inject the Trust Boundary Guard Replace the function with this logic. We explicitly check if event.account exists. If it does, we IGNORE the event, because SaaS billing happens on the Platform, not the Tenant.

TypeScript

// server/webhookHandlers.ts

async function handleSubscriptionUpdated(event: Stripe.Event): Promise<WebhookResult> {
  // 1. TRUST BOUNDARY CHECK (The Fix)
  // SaaS Plans (Free/Pro) are sold by US (The Platform). 
  // If event.account is present, this event came from a User's Connected Account.
  // We MUST ignore these for billing purposes to prevent the "Free Pro" exploit.
  if (event.account) {
    return { 
      processed: true, 
      action: 'ignored', 
      reason: 'Security Guard: Ignoring tenant-side subscription event' 
    };
  }

  const subscription = event.data.object as Stripe.Subscription;
  
  // 2. Identify the Merchant via Stripe Customer ID
  // Note: We need to find which merchant owns this Stripe Customer ID (stripeCustomerId).
  // Ideally, we search by 'stripeCustomerId' in the merchants table.
  // Since our schema might strictly link via 'stripeConnectId', we need to be careful.
  
  // CRITICAL: For this Hotfix, we assume we can't easily map the customer if the schema
  // doesn't support 'stripe_customer_id'.
  // HOWEVER, blocking the exploit is priority #1. 
  // If we can't find the user, we log an error, but at least we don't grant free upgrades to hackers.

  const stripeCustomerId = subscription.customer as string;
  const priceId = subscription.items.data[0]?.price.id;

  if (!priceId) {
    return { processed: true, action: 'ignored', reason: 'No price ID found' };
  }

  // Attempt to update. If we can't find the merchant by Customer ID, we fail safe.
  try {
    // We might need to add a method to storage to find by Customer ID, or query merchants directly.
    // For now, let's try to update based on the logic that we DO have. 
    // If we can't find them, we return 'ignored' rather than crashing.
    
    // HOTFIX STRATEGY:
    // If your schema only has `stripeConnectId`, you technically CANNOT map Platform events to Merchants yet.
    // In that case, this function acts as a pure shield (Blocking the exploit) until we add `stripeCustomerId` to the schema.
    
    return { 
      processed: true, 
      action: 'ignored', 
      reason: 'SaaS Billing Event received (Exploit Blocked). Pending: Schema update for stripeCustomerId lookup.' 
    };

  } catch (error: any) {
    return { 
      processed: false, 
      action: 'error', 
      reason: `Failed to sync plan: ${error.message}` 
    };
  }
}
Step 3: Verify the Switch Statement Ensure handleStripeWebhook calls this function for customer.subscription.updated.

VERIFICATION:

Exploit Test: Simulate a webhook with event.account = "acct_TEST".

Expect: Result is action: 'ignored', reason: 'Security Guard...'.

Result: The merchant's plan DOES NOT CHANGE.