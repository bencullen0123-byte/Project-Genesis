SYSTEM DIRECTIVE: SPRINT 9.5 - TICKET 3 (IDEMPOTENCY LOCK)

Objective: Prevent race conditions in webhook processing by acquiring an atomic database lock before execution.

Task 1: Add Locking Mechanism (server/storage.ts)

File: server/storage.ts

Action: Add the attemptEventLock method to the DatabaseStorage class. This attempts to insert the event ID and returns true ONLY if it was the first to do so.

TypeScript

  // server/storage.ts
// Add to Interface // attemptEventLock(eventId: string): Promise;

// Add to Class async attemptEventLock(eventId: string): Promise { const [locked] = await db.insert(processedEvents) .values({ eventId }) .onConflictDoNothing() .returning(); return !!locked; }


**Task 2: Enforce Lock at Entry (`server/webhookHandlers.ts`)**
File: server/webhookHandlers.ts

Action: Refactor handleStripeWebhook.

Remove the storage.hasProcessedEvent check.

Call storage.attemptEventLock(event.id) immediately.

Abort if the lock fails.

Remove all downstream calls to storage.markEventProcessed (since we already did it at the start).

Implementation Guide:

TypeScript

// server/webhookHandlers.ts
export async function handleStripeWebhook(event: Stripe.Event): Promise { const eventId = event.id;

// 1. ATOMIC LOCK (The Fix) // Try to insert. If it exists, this returns false immediately. const isFirstProcessing = await storage.attemptEventLock(eventId);

if (!isFirstProcessing) { return { processed: false, action: 'ignored', reason: Event ${eventId} handled by parallel worker (idempotency lock), }; }

// 2. Process (No need to mark processed again later) switch (event.type) { case 'invoice.payment_failed': return handleInvoicePaymentFailed(event); // ... (remove other markEventProcessed calls in the sub-functions) default: return { processed: true, action: 'ignored', reason: Event type ${event.type} not handled }; } }


**Verification:**
If two requests hit handleStripeWebhook with the same ID at the same microsecond, the Database Constraint will reject the second one.